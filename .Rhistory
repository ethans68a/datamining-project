#### PROBLEM F ####
# Part 1
getSymbols(Symbols = "EBS", from= '2015-01-05', to='2019-12-31')
d1 <- EBS$EBS.Adjusted
rtn <- dailyReturn(d1,type='log')
training <- rtn[1:1200]
m1 <- auto.arima(training)
acf(m1$residuals)
pacf(m1$residuals)
Box.test(m1$residuals,type="Ljung")
m1 <- auto.arima(training)
summary(m1)
acf(m1$residuals)
pacf(m1$residuals)
Box.test(m1$residuals,type="Ljung")
adf.test(m1$residuals)
coeftest(m1)
m2 <- arima(training,order=c(2,0,2))
summary(m2)
tsdiag(m2)
acf(m2$residuals)
pacf(m2$residuals)
Box.test(m2$residuals)
adf.test(m2$residuals)
coeftest(m2)
# Part 2
portfolio <- 100000
trades <- 0
prev <- training$daily.returns[1200]
for (i in 1200:1256){
temp_model <- arima(data[(i-1199):i],c(2,0,3)) # order is fixed and based on initial auto.arima
fore <- forecast(temp_model,h=1)
fore <- as.numeric(fore$mean)
if (fore > prev){
today_close <- as.numeric(EBS$EBS.Close[i])
tomorrow_close <- as.numeric(EBS$EBS.Close[i+1])
num_shares <- portfolio/today_close
portfolio <- 0
portfolio <- portfolio + (num_shares * tomorrow_close)
trades <- trades + 1
}
prev <- fore
}
print(trades)
print(portfolio)
# Part 2
portfolio <- 100000.0
trades <- 0
prev <- training$daily.returns[1200]
for (i in 1200:1256){
temp_model <- arima(data[(i-1199):i],c(2,0,3)) # order is fixed and based on initial auto.arima
fore <- forecast(temp_model,h=1)
fore <- as.numeric(fore$mean)
if (fore > prev){
today_close <- as.numeric(EBS$EBS.Close[i])
tomorrow_close <- as.numeric(EBS$EBS.Close[i+1])
num_shares <- portfolio/today_close
portfolio <- 0.0
portfolio <- portfolio + (num_shares * tomorrow_close)
trades <- trades + 1
}
prev <- fore
}
print(trades)
print(portfolio)
plot(rtn) # daily log returns
sqrd_rtn <- (rtn)^2
Box.test(sqrd_rtn,type="Ljung")
acf(sqrd_rtn)
pacf(sqrd_rtn)
e <- c(1,2,3)
e * 3
e <- list(1,2,3)
e * 3
?aggregate
?do.call
cbind(list(test))
clear
?cbind
?do.call
?do.call
?include
?import
??import
?library
?require
?attach
?sqldf
??sqldf
??sql
??postgres
??postgresql
??mysql
??connection
?str
??as.character.person
??as.character
?as.character
character(x)
character(1)
character("1")
?character
as.character(1)
as.character(list("1"))
as.character(list("1",2,3))
as.character
lm
lm.fit()
lm.fit
lm.fit()
?input
??input
library(nutshell)
download.file("https://cran.r-project.org/src/contrib/Archive/nutshell.audioscrobbler/nutshell.audioscrobbler_1.0.tar.gz", "nutshell.audioscrobbler_1.0.tar.gz")
download.file("https://cran.r-project.org/src/contrib/Archive/nutshell.bbdb/nutshell.bbdb_1.0.tar.gz", "nutshell.bbdb_1.0.tar.gz")
download.file("https://cran.r-project.org/src/contrib/Archive/nutshell/nutshell_2.0.tar.gz", "nutshell_2.0.tar.gz")
install.packages("nutshell.audioscrobbler_1.0.tar.gz", repos = NULL)
install.packages("nutshell.bbdb_1.0.tar.gz", repos = NULL)
install.packages("nutshell_2.0.tar.gz", repos = NULL)
library(nutshell)
data(births2006.smpl)
library(lattice)
?data
dt <- data(births2006.smpl)
dt <- births2006.smpl
help("VADeaths")
?which
count <- c()
for (i in 1:7){
count[i] <- length(which(dt$DOB_WK==category[i]))
}
category <- levels(factor(dt$DOB_WK))
count <- c()
for (i in 1:7){
count[i] <- length(which(dt$DOB_WK==category[i]))
}
?factor
factor((dt$DOB_WKB))
factor((dt$DOB_WK))
View(factor((dt$DOB_WK)))
?which
which(LETTERS = "R")
which(LETTERS == "R")
?levels
levels(factor(dt$DOB_WK))
(factor(dt$DOB_WK))
dow <- table(dt$DOB_WK)
View(dow)
dow <- table(dt$DOB_WK) # table, with frequency automatically made
barchart(dow,ylab="day of week",col="black")
# separate dataset corresponding to one categorical variable
dow_dm <- table(WK=dt$DOB_WK,MM=dt$DMETH_REC)
View(dow_dm)
dow_dm
dow_dm <- dow_dm[,-2] #forgot this syntax for subset
dow_dm
barchart(dow_dm,ylab="Day of week")
?col
col(1,2)
?barchart
barchart(dow_dm,ylab="Day of week",col(1,2))
barchart(dow_dm,ylab="Day of week",col=c(1,2))
barchart(dow_dm[,-2],ylab="Day of week",col=c(1,2))
barchart(dow_dm,ylab="Day of week",col=c(1,2))
# separate dataset corresponding to one categorical variable
dow_dm <- table(WK=dt$DOB_WK,MM=dt$DMETH_REC)
dow_dm <- dow_dm[,-2] # forgot this syntax for subset
barchart(dow_dm,ylab="Day of week",col=c(1,2))
dow_dm
barchart(dow_dm,ylab="day of week")
barchart(dow_dm[,-2],ylab="Day of week",col=c(1,2))
dow_dm <- dow_dm[,-2] # forgot this syntax for subset
barchart(dow_dm,ylab="Day of week",col=c(1,2))
barchart(dow_dm,ylab="Day of week",col=c(1,2))
barchart(dow_dm[,-2],ylab="day of week")
# separate dataset corresponding to one categorical variable
dow_dm <- table(WK=dt$DOB_WK,MM=dt$DMETH_REC)
barchart(dow_dm,ylab="Day of week",col=c(1,2))
barchart(dow_dm[,-2],ylab="day of week")
dow <- table(dt$DOB_WK) # table, with frequency automatically calculated
barchart(dow,ylab="day of week",col="black")
# separate dataset corresponding to one categorical variable
dow_dm <- table(WK=dt$DOB_WK,MM=dt$DMETH_REC)
# forgot the syntax meaning for subset
dow_dm
barchart(dow_dm,ylab="Day of week",col=c(1,2))
barchart(dow_dm[,-2],ylab="Day of week",col=c(1,2))
barchart(dow_dm,ylab="day of week")
# histogram from lattice package
histogram(dt$DBWT,col="blue",type="density")
# hist from R base
hist(dt$DBWT,col="black", main="histogram birth weight of baby",xlab="DBWT")
# birthday weight
histogram(~DBWT|DPLURAL)
~DBWT
~DBWT
e
# birthday weight. column ,followed by the data, 1 column 5 rows.
histogram(~DBWT|DPLURAL,data=dt,layout=c(1,5),col="black")
# birthday weight. column ,followed by the data, 1 column 5 rows.
histogram(~DBWT|DPLURAL,data=dt,layout=c(1,5),col="black",type="count") # same plot as ch.2 in book
?levls
?levels
dt$DBWT|DMETH_REC
histogram(~DBWT|DMETHREC,data=dt)
histogram(~DBWT|DMETH_REC,data=dt)
dt$DBWT|DMETH_REC
~DBWT|DMETH_REC
~DBWT|DMETH_REC,data=dt
# type = "count" will give you a frequency
histogram(~DBWT|DMETH_REC,data=dt,type="count")
# type = "count" will give you a frequency
histogram(~DBWT|DMETH_REC,data=dt,type="count")
# birthday weight. column ,followed by the data, 1 column 5 rows layout
histogram(~DBWT|DPLURAL,data=dt,layout=c(1,5),col="black",type="count") # same plot as ch.2 in book
# type = "count" will give you a frequency
histogram(~DBWT|DMETH_REC,data=dt,type="count")
# type = "count" will give you a frequency
histogram(~DBWT|DMETH_REC,data=dt)
# type = "count" will give you a frequency
histogram(~DBWT|DMETH_REC,data=dt,layout=c(1,3))
# type = "count" will give you a frequency
histogram(~DBWT|DMETH_REC,data=dt,layout=c(3,1))
# type = "count" will give you a frequency
histogram(~DBWT|DMETH_REC,data=dt,layout=c(3,1),type="count")
?hist
?plot
?plot
# density plot
densityplot(dt$DBWT,col="blue")
?data
?data
class(dt)
read.csv()
?read.csv
densityplot(~DBWT|DPLURAL,data=dt,layout=c(1,5),plot.point=F,col="red") # may take some time to run
# can either use different subplots or can use different colors to represent categories
densityplot(~DBWT,groups=DPLURAL,data=dt,plot.point=F)
?plot
# scatter plot
plot(dt$DBWT,dt$ESTGEST,type="p")
# scatter plot
plot(dt$DBWT[1:100],dt$ESTGEST,type="p")
# scatter plot
plot(dt$DBWT[1:100],dt$ESTGEST[1:100],type="p")
help("births2006.smpl")
plot(dt$DBWT[1:100],dt$ESTGEST[1:100],type="p",type="b",pch=16,lty=1)
plot(dt$DBWT[1:100],dt$ESTGEST[1:100],type="b",pch=16,lty=1)
xyplot(DBWT~DOB_WK|DPLRUAL,data=dt,layout=c(1,5,col="black"))
xyplot(DBWT~DOB_WK|DPLURAL,data=dt,layout=c(1,5,col="black"))
xyplot(DBWT~DOB_WK|DPLURAL,data=dt,layout=c(1,5),col="black")
# alternative scatter plot style
smoothScatter(dt$WTGAIN,dt$DBWT)
# alternative scatter plot style
smoothScatter(dt$WTGAIN,dt$DBWT,nrpoints = 200)
# alternative scatter plot style
smoothScatter(dt$WTGAIN,dt$DBWT,nrpoints = 200,col="red")
LETTERS[1]
letters[3]
?find
match(c("b","u"),letters)
?match
for(i in "ABC"){
print(i)
}
for(i in "RUTGERS"){
match(c(i),LETTERS)
}
print(match(c(i),LETTERS))
for(i in "RUTGERS"){
print(i)
print(match(c(i),LETTERS))
}
for(i in "R U T G E R S"){
print(i)
print(match(c(i),LETTERS))
}
for(i in strsplit("RUTGERS")){
print(match(c(i),LETTERS))
}
for(i in strsplit("RUTGERS","")){
print(match(c(i),LETTERS))
}
?strsplit
strsplit
codetools::walkCode()
arima(x)
as.character(4)
as.integer("34")
?predict
clear
c
data(iris)
print(data(iris))
iris
plot(iris)
dow
dow_dm
births2006.smpl
iris
rm
r?rm
?rm
?ls
ls()
stop()
data.frame(test=c(1,2,3),bananas=c(3,4,5))
data.frame(test=c(1,4343,3),bananas=c(3,4,5))
# random samples from normal distribution
# args: how many you want to choose
# randomly choose numbers from the normal distribution
rnorm(10)
# random samples from normal distribution
# args: how many you want to choose
# randomly choose numbers from the normal distribution
rnorm(10)
# random samples from normal distribution
# args: how many you want to choose
# randomly choose numbers from the normal distribution
rnorm(10)
# random samples from normal distribution
# args: how many you want to choose
# randomly choose numbers from the normal distribution
rnorm(10)
plot(x)
# random samples from normal distribution
# args: how many you want to choose
# randomly choose numbers from the normal distribution
x <- rnorm(10)
plot(x)
# random samples from normal distribution
# args: how many you want to choose
# randomly choose numbers from the normal distribution
x <- rnorm(100)
plot(x)
# random samples from normal distribution
# args: how many you want to choose
# randomly choose numbers from the normal distribution
x <- rnorm(1000)
plot(x)
clear
help("rm")
help(rm)
-0.5*(log(0.5))
log(2)
log(2)
log(2)
log(2)
log(1/2)
log10(10)
log(2)
log2(2)
log2
-0.5*log2(0.5)
log2(0.5)
*-0.5
-1*-0.5
log2(0)
log2(0)
log2(0)
log10(10)
log2(1)
log(1)
log2(1)
log2(6/8)
log(0.75)
6/8
log2(0.74)
log2(0.75)
log2(2/8)
-6/8(-0.415)
-6/8*(-0.415)
-2/8(-2)
-2/8(-2)
(-2/8)*(-2)
log2(6/8)
log2(2/8)
-6/8*(-0.415)
(-2/8*(-2))
log2(2/8)
-2*-2/8
log2(6/8)
-0.415*(-6/8)
log2(4/12)
(4/12)*-1.584963
(8/12)*log2(8/12)
0.528321+0.389975
summary(fit)
summary
(8/20)*0.81125
(12/20)*0.81125
0.48675+0.3245
(12/20)*0.918
0.5508+0.3245
1/4*log2(1/4)
3/4*log2(3/4)
-18(2/8)
-1*(2/8)
log2(2/8)
(6/8)*log2(6/8)
-2/8*-2
+0.3112781
0.5+0.3112781
log2(7/8)
log2(1/8)
-7/8*-0.19264
0.16856+(3/8)
4/20*(0.81128)
8/20*(0.54356)
8/20(0.81125)
8/20*(0.81125)
0.3245+0.217424+0.162256
1-0.8753
14/15
help()
??
?
clear
\n
stop()
stop
plot(1)
?acf
?matrix
plot(m1$res~m1$fitted)
# multiple linear regression, numeric only - predict valence
m1 <- lm(Valence~.,data=spotify_df_valence)
print(summary(m1))
setwd("~/Documents/Fall-2021/datamining/spotify-project")
spotify_clean <- read.csv("csv/spotify-2000-clean.csv")
spotify_df <- data.frame(spotify_clean)
spotify_tr_df <- spotify_df[1:1200,]
spotify_test_df <- spotify_df[1201:nrow(spotify_df),]
# remove irrelevant attributes
spotify_tr_df_valence <- subset(spotify_tr_df,select = -c(Title,Artist,Year,Popularity,TopGenre))
# multiple linear regression, numeric only - predict valence
m1 <- lm(Valence~.,data=spotify_df_valence)
# multiple linear regression, numeric only - predict valence
m1 <- lm(Valence~.,data=spotify_tr_df_valence)
print(summary(m1))
plot(m1$res~m1$fitted)
m1$terms
m1$model
getOption
else
stop()
warning()
errorCondition()
stopifnot()
stopifnot(F)
stop()
stop("hi")
try {}
spotify_tr_df_valence$Beats.Per.Minute..BPM.
plot(m1$res~spotify_tr_df_valence[,"Energy"])
names(spotify_tr_df_valence)
names(spotify_tr_df_valence) - c("Valence")
names(spotify_tr_df_valence)
class(names(spotify_tr_df_valence))
names
names(spotify_tr_df_valence)
c("Valence")
setdiff(names(spotify_tr_df_valence),c("Valence"))
setdiff(names(spotify_tr_df_valence),c("Valence","Bananas"))
?setdiff
# plot residuals vs Xi1 ... Xik
for (colname in setdiff(names(spotify_tr_df_valence),c("Valence"))){
plot(m1$res~spotify_tr_df_valence[,colname],main=paste("Residuals vs ", colname))
}
# plot residuals vs Xi1 ... Xik
for (colname in setdiff(names(spotify_tr_df_valence),c("Valence"))){
plot(m1$res~spotify_tr_df_valence[,colname],main=paste("Residuals vs",colname))
}
# plot residuals vs Xi1 ... Xik
for (colname in setdiff(names(spotify_tr_df_valence),c("Valence"))){
plot(m1$res~spotify_tr_df_valence[,colname],main=paste("Residuals vs",colname),ylab="Residuals",xlab=colname)
}
library(leaps)
library
X<-spotify_tr_df_valence[,2:ncol(spotify_tr_df_valence)]
y<-spotify_tr_df_valence[,1]
out<-summary(regsubsets(X,y,nbest=2,nvmax=ncol(X))) # 'nbest' is the number of top models shown for subset size
tab1<-cbind(out$which,out$rsq,out$adjr2,out$cp) # organize the results into a table
print(tab1)
print(tab1)
?regsubsets
spotify_tr_df_valence
names(spotify_clean)
names(spotify_tr_df_valence
)
out$which[1]
out$which
class(out$which)
X <- spotify_tr_df_valence[, -c("Valence")]
!names(mtcars) %in% c("carb", "mpg")
mtcars
?mtcar
?mtcars
!names(spotify_tr_df_valence) %in% c("Valence")
X
X
X <- spotify_tr_df_valence[, !names(spotify_tr_df_valence) %in% c("Valence")]
y <- spotify_tr_df_valence[, "Valence"]
out <-
summary(regsubsets(X, y, nbest = 2, nvmax = ncol(X))) # 'nbest' is the number of top models shown for subset size
tab1 <-
cbind(out$which, out$rsq, out$adjr2, out$cp) # organize the results into a table
print(tab1)
summary(m1)
print(tab1)
step(m1)
print(tab1)
